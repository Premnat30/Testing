import os
import time
import subprocess
import paramiko
from flask import Flask, render_template, request, Response, abort, session, redirect, url_for, jsonify, stream_with_context
from flask_session import Session
import secrets
import logging
from config import get_host_config  # Import from config.py

app = Flask(__name__)
app.secret_key = os.urandom(24)

# --- Flask-Session Configuration ---
app.config["SESSION_TYPE"] = "filesystem"
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_USE_SIGNER"] = True
app.config["SESSION_KEY_PREFIX"] = "my_app_session_"
app.config["SESSION_FILE_DIR"] = "/tmp/flask_session"
Session(app)

# Ensure the session directory exists
if not os.path.exists(app.config["SESSION_FILE_DIR"]):
    os.makedirs(app.config["SESSION_FILE_DIR"])

def _parse_ps_output(output_lines):
    """
    Parses the output of the 'ps aux' command into a list of process dictionaries.
    """
    processes = []
    for line in output_lines[1:]:
        parts = line.split()
        if len(parts) >= 11:
            process_info = {
                'user': parts[0],
                'pid': parts[1],
                'cpu': parts[2],
                'mem': parts[3],
                'vsz': parts[4],
                'rss': parts[5],
                'tty': parts[6],
                'stat': parts[7],
                'start': parts[8],
                'time': parts[9],
                'command': ' '.join(parts[10:])
            }
            processes.append(process_info)
    return processes

def _get_ssh_client(hostname_config, username, password):
    """Establishes an SSH connection to a remote host using a password."""
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(
            hostname=hostname_config['hostname'],
            username=username,  # Use the provided username
            password=password,
            look_for_keys=False,
            timeout=10
        )
        return client
    except paramiko.AuthenticationException:
        app.logger.error(f"Authentication failed for {hostname_config['hostname']} with user {username}")
        return None
    except Exception as e:
        app.logger.error(f"SSH connection failed for {hostname_config['hostname']}: {e}")
        return None

# --- Get host credentials from session ---
def get_host_credentials(hostname_key):
    """Retrieves the credentials for a host from the session."""
    credentials = session.get('credentials', {})
    return credentials.get(hostname_key, {})

# --- Authentication Route ---
@app.route('/authenticate', methods=['GET', 'POST'])
def authenticate():
    HOST_CONFIG = get_host_config()  # Call function to get host config
    
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        authenticated_hosts = {}
        
        for hostname_key, hostname_config in HOST_CONFIG.items():
            client = _get_ssh_client(hostname_config, username, password)
            if client:
                client.close()
                authenticated_hosts[hostname_key] = {
                    'username': username,
                    'password': password
                }

        if authenticated_hosts:
            session['credentials'] = authenticated_hosts
            session['current_user'] = username
            return redirect(url_for('index'))
        else:
            return render_template('authenticate.html', 
                                 hosts=HOST_CONFIG.keys(), 
                                 error="Authentication failed for all hosts with the provided credentials.")
    
    return render_template('authenticate.html', hosts=HOST_CONFIG.keys())

# --- Index Route for Log Searching ---
@app.route('/')
def index():
    if 'credentials' not in session or not session['credentials']:
        return redirect(url_for('authenticate'))

    HOST_CONFIG = get_host_config()
    hostname_key = request.args.get('hostname')
    if not hostname_key or hostname_key not in session['credentials']:
        hostname_key = next(iter(session['credentials']), None)

    credentials = get_host_credentials(hostname_key)
    if not credentials:
        return redirect(url_for('authenticate'))

    hostname_config = HOST_CONFIG.get(hostname_key)
    client = _get_ssh_client(hostname_config, credentials['username'], credentials['password'])
    if not client:
        session.get('credentials', {}).pop(hostname_key, None)
        return redirect(url_for('authenticate'))

    filename_filter = request.args.get('filename_filter', '').lower()
    log_files = []
    try:
        stdin, stdout, stderr = client.exec_command(f"ls {hostname_config['log_dir']}")
        all_files = stdout.read().decode().strip().split('\n')
        client.close()
        if filename_filter:
            log_files = [f for f in all_files if filename_filter in f.lower()]
        else:
            log_files = all_files
        log_files.sort()
    except Exception as e:
        return f"An error occurred while reading the remote log directory: {e}", 500

    return render_template('search.html',
        log_files=log_files,
        filename_filter=filename_filter,
        hosts=HOST_CONFIG.keys(),
        selected_host=hostname_key,
        username=session.get('current_user', 'Unknown')
    )

# --- Process Task Route ---
@app.route('/processes/<hostname_key>')
def process_task(hostname_key):
    # Check for authentication
    credentials = get_host_credentials(hostname_key)
    if not credentials:
        return redirect(url_for('authenticate'))

    HOST_CONFIG = get_host_config()
    hostname_config = HOST_CONFIG.get(hostname_key)
    if not hostname_config:
        abort(404, description="Host not found.")

    processes = []
    error = None
    client = _get_ssh_client(hostname_config, credentials['username'], credentials['password'])
    if client:
        try:
            stdin, stdout, stderr = client.exec_command('ps aux')
            output = stdout.read().decode('utf-8').splitlines()
            processes = _parse_ps_output(output)
        except Exception as e:
            error = f"Failed to fetch processes: {e}"
        finally:
            client.close()
    else:
        error = f"Failed to connect to host '{hostname_key}'."
    
    return render_template('process_task.html',
        host_name=hostname_key,
        processes=processes,
        error=error,
        hosts=HOST_CONFIG.keys(),
        username=session.get('current_user', 'Unknown')
    )

LOGS_DIR = os.path.abspath('/apps/logs/s2bxtb01/')

@app.route('/search', methods=['GET'])
def search_logs():
    selected_log = request.args.get('log_file')
    query = request.args.get('query', '')
    hostname_key = request.args.get('hostname')
    results = []

    if not selected_log:
        return "No log file selected.", 400

    requested_path = os.path.join(LOGS_DIR, selected_log)
    real_requested_path = os.path.realpath(requested_path)

    if not real_requested_path.startswith(LOGS_DIR):
        return "Invalid log file path.", 400

    try:
        with open(real_requested_path, 'r', encoding='utf-8', errors='ignore') as log_file:
            for line in log_file:
                if query.lower() in line.lower():
                    results.append(line.strip())
    except FileNotFoundError:
        return f"Log file '{selected_log}' not found.", 404
    except Exception as e:
        return f"An error occurred: {e}", 500

    HOST_CONFIG = get_host_config()
    return render_template('search_result.html',
        query=query,
        results=results,
        selected_log=selected_log,
        selected_host=hostname_key,
        hosts=HOST_CONFIG.keys(),
        username=session.get('current_user', 'Unknown')
    )

# --- Tail Log Route ---
@app.route('/tail/<hostname_key>/<path:filename>')
def tail_log(hostname_key, filename):
    HOST_CONFIG = get_host_config()
    if hostname_key not in HOST_CONFIG:
        return "Invalid hostname.", 400
    if not get_host_credentials(hostname_key):
        return redirect(url_for('authenticate', hostname=hostname_key))
    
    return render_template('tail.html', 
                         log_file=filename, 
                         hostname_key=hostname_key, 
                         hosts=HOST_CONFIG.keys(),
                         username=session.get('current_user', 'Unknown'))

@app.route('/stream/<hostname_key>/<path:filename>')
def stream_logs(hostname_key, filename):
    credentials = get_host_credentials(hostname_key)
    if not credentials:
        return Response("Error: Authentication required for this host.", status=401)
    
    HOST_CONFIG = get_host_config()
    hostname_config = HOST_CONFIG.get(hostname_key)
    if not hostname_config:
        return "Invalid hostname.", 400

    client = _get_ssh_client(hostname_config, credentials['username'], credentials['password'])
    if not client:
        return f"Could not connect to host '{hostname_key}'.", 500
    
    log_file_path = os.path.join(hostname_config['log_dir'], filename)

    return Response(stream_with_context(follow_remote(client, log_file_path)), mimetype='text/event-stream')

def follow_remote(client, log_file_path):
    try:
        command = f"tail -f -n 100 '{log_file_path}'"
        transport = client.get_transport()
        channel = transport.open_session()
        channel.exec_command(command)
        
        while not channel.exit_status_ready():
            if channel.recv_ready():
                output = channel.recv(1024).decode('utf-8', errors='ignore')
                for line in output.splitlines():
                    yield f"data: {line}\n\n"
            else:
                time.sleep(0.5)
        
        # Process any remaining output
        while channel.recv_ready():
            output = channel.recv(1024).decode('utf-8', errors='ignore')
            for line in output.splitlines():
                yield f"data: {line}\n\n"
        
        yield f"data: --- Command finished with status {channel.exit_status_ready()} ---\n\n"

    except Exception as e:
        yield f"data: --- Error during streaming: {e} ---\n\n"
    finally:
        client.close()

# --- Logout Route ---
@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('authenticate'))

