import os
import time
import subprocess
import paramiko
from flask import Flask, render_template, request, Response, abort, redirect, url_for, jsonify, stream_with_context
from config import get_host_config

app = Flask(__name__)
app.secret_key = os.urandom(24)

def _get_ssh_client(hostname_config):
    """Establishes an SSH connection to a remote host using SSH keys."""
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(
            hostname=hostname_config['hostname'],
            username=hostname_config['username'],
            look_for_keys=True,  # Use SSH keys instead of password
            allow_agent=True,    # Use SSH agent if available
            timeout=10
        )
        return client
    except Exception as e:
        app.logger.error(f"SSH connection failed for {hostname_config['hostname']}: {e}")
        return None

# --- Index Route for Log Searching ---
@app.route('/')
def index():
    HOST_CONFIG = get_host_config()
    hosts_list = list(HOST_CONFIG.keys())
    
    hostname_key = request.args.get('hostname')
    if not hostname_key or hostname_key not in HOST_CONFIG:
        hostname_key = hosts_list[0] if hosts_list else None

    if not hostname_key:
        return "No hosts configured", 500

    hostname_config = HOST_CONFIG.get(hostname_key)
    client = _get_ssh_client(hostname_config)
    if not client:
        return f"SSH connection failed for {hostname_key}. Please ensure SSH keys are configured.", 500

    filename_filter = request.args.get('filename_filter', '').lower()
    log_files = []
    try:
        stdin, stdout, stderr = client.exec_command(f"ls {hostname_config['log_dir']}")
        all_files = stdout.read().decode().strip().split('\n')
        client.close()
        if filename_filter:
            log_files = [f for f in all_files if filename_filter in f.lower()]
        else:
            log_files = all_files
        log_files.sort()
    except Exception as e:
        return f"An error occurred while reading the remote log directory: {e}", 500

    return render_template('search.html',
        log_files=log_files,
        filename_filter=filename_filter,
        hosts=hosts_list,
        selected_host=hostname_key
    )

# --- Process Task Route ---
@app.route('/processes/<hostname_key>')
def process_task(hostname_key):
    HOST_CONFIG = get_host_config()
    hostname_config = HOST_CONFIG.get(hostname_key)
    if not hostname_config:
        abort(404, description="Host not found.")

    processes = []
    error = None
    client = _get_ssh_client(hostname_config)
    if client:
        try:
            stdin, stdout, stderr = client.exec_command('ps aux')
            output = stdout.read().decode('utf-8').splitlines()
            processes = _parse_ps_output(output)
        except Exception as e:
            error = f"Failed to fetch processes: {e}"
        finally:
            client.close()
    else:
        error = f"Failed to connect to host '{hostname_key}'. Please ensure SSH keys are configured."
    
    return render_template('process_task.html',
        host_name=hostname_key,
        processes=processes,
        error=error,
        hosts=list(HOST_CONFIG.keys())
    )

def _parse_ps_output(output):
    """Parse ps aux output and return list of processes."""
    processes = []
    if not output:
        return processes
    
    headers = output[0].split()
    for line in output[1:]:
        if line.strip():
            parts = line.split(None, len(headers)-1)
            if len(parts) == len(headers):
                processes.append(dict(zip(headers, parts)))
    return processes

LOGS_DIR = os.path.abspath('/apps/logs/s2bxtb01/')

@app.route('/search', methods=['GET'])
def search_logs():
    selected_log = request.args.get('log_file')
    query = request.args.get('query', '')
    hostname_key = request.args.get('hostname')
    results = []

    if not selected_log:
        return "No log file selected.", 400

    requested_path = os.path.join(LOGS_DIR, selected_log)
    real_requested_path = os.path.realpath(requested_path)

    if not real_requested_path.startswith(LOGS_DIR):
        return "Invalid log file path.", 400

    try:
        with open(real_requested_path, 'r', encoding='utf-8', errors='ignore') as log_file:
            for line in log_file:
                if query.lower() in line.lower():
                    results.append(line.strip())
    except FileNotFoundError:
        return f"Log file '{selected_log}' not found.", 404
    except Exception as e:
        return f"An error occurred: {e}", 500

    HOST_CONFIG = get_host_config()
    return render_template('search_result.html',
        query=query,
        results=results,
        selected_log=selected_log,
        selected_host=hostname_key,
        hosts=list(HOST_CONFIG.keys())
    )

# --- Tail Log Route ---
@app.route('/tail/<hostname_key>/<path:filename>')
def tail_log(hostname_key, filename):
    HOST_CONFIG = get_host_config()
    if hostname_key not in HOST_CONFIG:
        return "Invalid hostname.", 400
    
    return render_template('tail.html', 
                         log_file=filename, 
                         hostname_key=hostname_key, 
                         hosts=list(HOST_CONFIG.keys()))

@app.route('/stream/<hostname_key>/<path:filename>')
def stream_logs(hostname_key, filename):
    HOST_CONFIG = get_host_config()
    hostname_config = HOST_CONFIG.get(hostname_key)
    if not hostname_config:
        return "Invalid hostname.", 400

    client = _get_ssh_client(hostname_config)
    if not client:
        return f"Could not connect to host '{hostname_key}'. Please ensure SSH keys are configured.", 500
    
    log_file_path = os.path.join(hostname_config['log_dir'], filename)

    return Response(stream_with_context(follow_remote(client, log_file_path)), mimetype='text/event-stream')

def follow_remote(client, log_file_path):
    try:
        command = f"tail -f -n 100 '{log_file_path}'"
        transport = client.get_transport()
        channel = transport.open_session()
        channel.exec_command(command)
        
        while not channel.exit_status_ready():
            if channel.recv_ready():
                output = channel.recv(1024).decode('utf-8', errors='ignore')
                for line in output.splitlines():
                    yield f"data: {line}\n\n"
            else:
                time.sleep(0.5)
        
        # Process any remaining output
        while channel.recv_ready():
            output = channel.recv(1024).decode('utf-8', errors='ignore')
            for line in output.splitlines():
                yield f"data: {line}\n\n"
        
        yield f"data: --- Command finished with status {channel.exit_status_ready()} ---\n\n"

    except Exception as e:
        yield f"data: --- Error during streaming: {e} ---\n\n"
    finally:
        client.close()

if __name__ == '__main__':
    app.run(host='localhost', port=5000, debug=True)
